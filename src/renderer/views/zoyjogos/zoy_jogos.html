<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zoy Jogos - Labirinto com Níveis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configuração do Tailwind para usar a fonte Inter e cores personalizadas
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'zoy-blue': '#1e40af',
                        'zoy-dark': '#0f172a',
                        'zoy-light': '#f1f5f9',
                        'panda-color': '#34d399', 
                    }
                }
            }
        }
    </script>
    <link rel="stylesheet" href="../home/home.css"> 
    <style>
    /* ------------------------------
       VARIÁVEIS DE ESTILO
    ------------------------------ */
    :root {
        --bg: #f1f5f9;
        --white: #ffffff;
        --border: #e2e8f0;
        --shadow-lg: 0 8px 20px rgba(0, 0, 0, 0.08);
        --shadow-sm: 0 4px 8px rgba(0, 0, 0, 0.05);
        --radius: 12px;
        --font: 'Inter', sans-serif;
    }

    /* ------------------------------
       GLOBAL
    ------------------------------ */
    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        font-family: var(--font);
        background: var(--bg);
        color: #1e293b;
    }

    /* ------------------------------
       LAYOUT PRINCIPAL
    ------------------------------ */
    #mainContainer {
        display: flex;
        flex-direction: column;
        height: 100%;
    }

    #gameAndBlockly {
        display: flex;
        flex-grow: 1;
        overflow: hidden;
    }

    /* ------------------------------
       ÁREA DO JOGO
    ------------------------------ */
    #gameArea {
        flex-basis: 40%;
        max-width: 40%;
        padding: 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        overflow-y: auto;
    }

    /* ------------------------------
       ÁREA DO BLOCKLY
    ------------------------------ */
    #blocklyArea {
        flex-basis: 60%;
        max-width: 60%;
        height: 100%;
        border-left: 1px solid var(--border);
        background: var(--white);
    }

    #blocklyGameWorkspace {
        width: 100%;
        height: 100%;
    }

    /* ------------------------------
       BARRA DE CONTROLES
    ------------------------------ */
    #controls {
        padding: 12px 24px;
        background: var(--white);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        gap: 20px;
        box-shadow: var(--shadow-sm);
        z-index: 10;
    }

    /* ------------------------------
       CANVAS DO LABIRINTO
    ------------------------------ */
    #gameCanvas {
        width: 100%;
        max-width: 100%;
        border-radius: var(--radius);
        background: var(--white);
        box-shadow: var(--shadow-lg);
    }

    /* ------------------------------
       RESPONSIVIDADE
    ------------------------------ */
    @media (max-width: 1024px) {
        #gameAndBlockly {
            flex-direction: column;
        }

        #gameArea,
        #blocklyArea {
            max-width: 100%;
            flex-basis: 100%;
            height: 50vh;
        }

        #blocklyArea {
            border-left: none;
            border-top: 1px solid var(--border);
        }
    }
</style>

</head>
<body>
    <div id="mainContainer">
        
        <div id="controls">
            <button 
                 class="mt-4 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out"
                 onclick="window.location.href='zoy_quiz.html'">
                 Quiz
            </button>
            <button 
                class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" 
                id="btnVoltar" 
                onclick="window.electronAPI.goBack()">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-left-short inline-block mr-1" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M12 8a.5.5 0 0 1-.5.5H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H11.5a.5.5 0 0 1 .5.5z"/>
                </svg>
                Voltar
            </button>
            
            <button 
                class="bg-zoy-blue hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" 
                id="btnExecutarPrograma" 
                onclick="window.executeProgram()">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill inline-block mr-1" viewBox="0 0 16 16">
                    <path d="m11.596 8.697-5.594 3.996c-.57.408-1.396-.039-1.396-.717V4.118c0-.678.825-1.125 1.396-.717l5.594 3.996a.9.9 0 0 1 0 1.314z"/>
                </svg>
                Executar
            </button>
            <button 
                class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" 
                id="btnPararPrograma" 
                onclick="window.stopProgram()" 
                disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-stop-fill inline-block mr-1" viewBox="0 0 16 16">
                    <path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/>
                </svg>
                Parar
            </button>
            
            <label for="difficultySelector" class="text-sm font-medium text-gray-700">Fase:</label>
            <select id="difficultySelector" onchange="window.setDifficulty(this.value)"
                    class="py-2 px-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-zoy-blue focus:border-zoy-blue sm:text-sm">
                <option value="easy">Fase 1: Movimento Básico (5x5)</option>
                <option value="medium">Fase 2: Curvas Simples (5x5)</option>
                <option value="hard">Fase 3: Labirinto Simples (7x7)</option>
                <option value="loop_challenge">Fase 4: Desafio de Repetição (5x5)</option>
                <option value="conditional_loop">Fase 5: Loop Condicional (7x7)</option>
                <option value="phase_6_turn_and_loop">Fase 6: Curvas Fechadas (5x5)</option>
                <option value="phase_7_conditional_path">Fase 7: Caminho Bifurcado (7x7)</option>
                <option value="phase_8_long_winding">Fase 8: Espiral Longa (7x7)</option>
                <option value="phase_9_double_loop">Fase 9: Desvio e Retorno (7x7)</option>
                <option value="phase_10_final_challenge">Fase 10: Desafio Final (8x8)</option>
            </select>

            <div id="statusMessage" class="px-3 py-1 rounded-lg text-sm bg-gray-100 text-gray-700 font-medium transition duration-150 ease-in-out">
                Pronto para começar.
            </div>

            </div>

        <div id="gameAndBlockly">
            <div id="gameArea">
                <h3 class="text-xl font-bold mb-4 text-zoy-dark">Labirinto do Robô Zoy</h3>
                <canvas id="gameCanvas" width="500" height="500"></canvas>
                <button 
                    class="mt-4 bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" 
                    onclick="window.resetGame()">
                    Reiniciar
                </button>
            </div>

            <div id="blocklyArea">
                <div id="blocklyGameWorkspace"></div>
            </div>
        </div>
    </div>

    <div id="codeDisplayOverlay" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50" style="display: none;">
        <div class="bg-white p-6 rounded-lg shadow-2xl max-w-xl w-11/12">
            <h4 class="text-lg font-bold text-zoy-dark mb-3">Código Gerado (JavaScript)</h4>
            <pre id="generatedCodeDisplay" class="bg-gray-800 text-green-300 p-4 rounded-md overflow-auto max-h-96 text-sm">
                Nenhum bloco conectado
            </pre>
            <button onclick="window.stopProgram()" 
                    class="mt-4 bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out">
                Fechar / Parar Programa
            </button>
        </div>
    </div>
    <xml id="toolboxMaze" style="display: none">
        <category name="Movimento" colour="#CC6666">
            <block type="maze_moveForward"></block>
            <block type="maze_turn"></block>
        </category>
        <category name="Controle" colour="#5CB85C">
            <block type="controls_repeat_simple"></block>
            <block type="controls_while_path"></block> 
            <block type="controls_if_path"></block>
            <block type="controls_if_else_path"></block>
        </category>
    </xml>

    <script src="zoy_jogos.js"></script>

    <script>
        // Variáveis Globais de Estado do Jogo (mantidas)
        let canvas, ctx;
        window.isRunning = false; 
        
        // 0=Parede, 1=Caminho, 2=Início (Robô Zoy), 3=Fim (Objetivo)
        
        // --- 1. DEFINIÇÃO DOS NÍVEIS DE DIFICULDADE (10 FASES) ---
        const MAZES = {
            // Fase 1: Movimento Básico
            easy: {
                size: 5,
                layout: [
                    [0, 0, 0, 0, 0], 
                    [0, 0, 0, 0, 0],
                    [2, 1, 1, 1, 3], 
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0] 
                ]
            },
            // Fase 2: Curvas Simples
            medium: {
                size: 5,
                layout: [
                    [2, 1, 0, 1, 1], 
                    [1, 1, 0, 0, 1],
                    [1, 0, 1, 1, 1],
                    [1, 0, 1, 0, 1],
                    [1, 1, 1, 0, 3]  
                ]
            },
            // Fase 3: Labirinto Simples
            hard: {
                size: 7,
                layout: [
                    [2, 1, 1, 0, 1, 1, 1], 
                    [0, 0, 1, 0, 1, 0, 1],
                    [1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 1, 1, 1],
                    [1, 1, 1, 1, 0, 1, 0],
                    [0, 1, 0, 1, 0, 1, 1],
                    [1, 1, 0, 1, 1, 1, 3]
                ]
            },
            // Fase 4: Desafio de Repetição
            loop_challenge: {
                size: 5,
                layout: [
                    [2, 1, 0, 0, 0], 
                    [1, 1, 0, 0, 0],
                    [1, 0, 0, 0, 0],
                    [1, 0, 0, 0, 0],
                    [1, 1, 1, 1, 3]  
                ]
            },
            // Fase 5: Loop Condicional
            conditional_loop: {
                size: 7,
                layout: [
                    [2, 1, 1, 1, 1, 1, 0], 
                    [0, 0, 0, 0, 0, 1, 0],
                    [0, 1, 1, 1, 1, 1, 0],
                    [0, 1, 0, 0, 0, 0, 0],
                    [0, 1, 1, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0, 1, 0],
                    [0, 1, 1, 1, 1, 1, 3] 
                ]
            },
            // Fase 6: Curvas Fechadas (Requer repetição e virar)
            phase_6_turn_and_loop: {
                size: 5,
                layout: [
                    [2, 1, 1, 1, 1],
                    [0, 0, 0, 0, 1],
                    [0, 0, 0, 0, 1],
                    [0, 0, 0, 0, 1],
                    [0, 0, 0, 0, 3]
                ]
            },
            // Fase 7: Caminho Bifurcado (Requer IF com virar)
            phase_7_conditional_path: {
                size: 7,
                layout: [
                    [2, 1, 1, 1, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0],
                    [0, 0, 0, 1, 0, 1, 0],
                    [0, 0, 0, 1, 0, 1, 0],
                    [0, 0, 0, 1, 0, 1, 0],
                    [0, 0, 0, 1, 1, 1, 3],
                    [0, 0, 0, 0, 0, 0, 0]
                ]
            },
            // Fase 8: Espiral Longa (Requer repetição e virar)
            phase_8_long_winding: {
                size: 7,
                layout: [
                    [2, 1, 1, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0, 1, 0],
                    [1, 1, 1, 1, 0, 1, 0],
                    [1, 0, 0, 1, 0, 1, 0],
                    [1, 0, 0, 1, 0, 1, 1],
                    [1, 0, 0, 1, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 3]
                ]
            },
            // Fase 9: Desvio e Retorno (Requer loop condicional)
            phase_9_double_loop: {
                size: 7,
                layout: [
                    [2, 1, 1, 0, 1, 1, 1],
                    [0, 0, 1, 0, 1, 0, 1],
                    [0, 0, 1, 0, 1, 0, 1],
                    [0, 0, 1, 1, 1, 0, 1],
                    [0, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0, 0, 3]
                ]
            },
            // Fase 10: Desafio Final (8x8) (Combinação de todos os blocos)
            phase_10_final_challenge: {
                size: 8,
                layout: [
                    [2, 1, 1, 1, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0, 0, 1, 0],
                    [0, 1, 1, 1, 1, 0, 1, 0],
                    [0, 1, 0, 0, 1, 0, 1, 0],
                    [0, 1, 0, 0, 1, 1, 1, 0],
                    [0, 1, 0, 0, 0, 0, 0, 0],
                    [0, 1, 1, 1, 1, 1, 1, 3],
                    [0, 0, 0, 0, 0, 0, 0, 0]
                ]
            }
        };

        let currentDifficulty = 'easy';
        let MAZE_SIZE = MAZES[currentDifficulty].size;
        let MAZE = MAZES[currentDifficulty].layout;
        
        let currentPosition = { x: 0, y: 0 }; 
        let currentDirection = 0; // 0: Right, 1: Down, 2: Left, 3: Up

        // Referência global para o elemento de status
        window.statusMessageElement = null; 
        
        // Cor do Robô (Zoy Blue)
        const ROBOT_COLOR = '#1e40af'; 
        const FACE_COLOR = '#ffffff';

        // --- FUNÇÕES AUXILIARES DE ESTADO ---

        /** Função para mudar a dificuldade e recarregar o labirinto. */
        window.setDifficulty = function(newDifficulty) {
            currentDifficulty = newDifficulty;
            const mazeConfig = MAZES[newDifficulty];
            
            if (!mazeConfig) {
                console.error(`Dificuldade desconhecida: ${newDifficulty}`);
                return;
            }
            
            MAZE = mazeConfig.layout;
            MAZE_SIZE = mazeConfig.size;
            window.resetGame(); // Reinicia o jogo com o novo labirinto
            
            // Redimensiona o workspace do Blockly após a mudança de fase
            if (window.workspaceMaze) {
                Blockly.svgResize(window.workspaceMaze);
            }
            
            window.updateStatus(`Fase alterada para ${newDifficulty.toUpperCase()}.`);
        }


        /** Função global para atualizar o status. */
        window.updateStatus = function(message, bgClass = 'bg-gray-100', textClass = 'text-gray-700') {
            if (!window.statusMessageElement) {
                console.error("ERRO DE DOM: Elemento statusMessage não encontrado.");
                return;
            }
            window.statusMessageElement.className = `px-3 py-1 rounded-lg text-sm font-medium ${bgClass} ${textClass}`;
            window.statusMessageElement.textContent = message;
        }

        /** Função de atraso (usada pelo código Blockly gerado) */
        window.delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        /** Reinicia o estado do jogo para a posição inicial. */
        window.resetGame = function() { 
            window.isRunning = false;
            // Encontra a posição inicial (tile 2)
            let foundStart = false;
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    if (MAZE[y][x] === 2) {
                        currentPosition = { x, y };
                        currentDirection = 0; // Direção inicial: Direita
                        foundStart = true;
                        break;
                    }
                }
                if (foundStart) break;
            }
            window.updateStatus('Labirinto Reiniciado. Pronto para programar!');
            drawMaze();
            // Garante que os botões estão no estado correto
            document.getElementById('btnExecutarPrograma').disabled = false;
            document.getElementById('btnPararPrograma').disabled = true;
        }

        // --- FUNÇÕES DE INTERAÇÃO DO JOGO (Chamadas pelo código Blockly gerado) ---
        
        /** Move o Robô uma casa para frente. */
        window.moveForward = async function() {
            if (!window.isRunning) return false;
            
            // Adiciona um atraso para a animação
            await window.delay(300); 

            let newX = currentPosition.x;
            let newY = currentPosition.y;

            // 0: Right (+x), 1: Down (+y), 2: Left (-x), 3: Up (-y)
            switch (currentDirection) {
                case 0: newX++; break;
                case 1: newY++; break;
                case 2: newX--; break;
                case 3: newY--; break;
            }

            // 1. Verifica limites
            if (newX < 0 || newX >= MAZE_SIZE || newY < 0 || newY >= MAZE_SIZE) {
                window.updateStatus('Colisão com a borda do mapa!', 'bg-red-200', 'text-red-900');
                window.isRunning = false;
                throw new Error('Collision or Game Over');
            }

            const nextTile = MAZE[newY][newX];

            // 2. Verifica parede
            if (nextTile === 0) {
                window.updateStatus('Colisão com uma parede!', 'bg-red-200', 'text-red-900');
                window.isRunning = false;
                throw new Error('Collision or Game Over');
            }
            
            // 3. Move o Robô
            currentPosition = { x: newX, y: newY };
            drawMaze();

            // 4. Verifica vitória (tile 3)
            if (nextTile === 3) {
                window.updateStatus('Parabéns! O Robô Zoy encontrou o Objetivo!', 'bg-green-200', 'text-green-800');
                window.isRunning = false;
                throw new Error('Game Over'); 
            }

            return true;
        };

        /** Vira o Robô. */
        window.turn = async function(direction) {
            if (!window.isRunning) return false;
            
            // Adiciona um atraso para a animação
            await window.delay(300);

            if (direction === 'LEFT') {
                currentDirection = (currentDirection + 3) % 4; 
            } else { // 'RIGHT'
                currentDirection = (currentDirection + 1) % 4; 
            }
            drawMaze();
            return true;
        };

        /** Verifica se há caminho livre na direção especificada. */
        window.isPath = function(checkDirection) {
            let dir = currentDirection;
            
            if (checkDirection === 'LEFT') {
                dir = (currentDirection + 3) % 4;
            } else if (checkDirection === 'RIGHT') {
                dir = (currentDirection + 1) % 4;
            } else if (checkDirection === 'FORWARD') {
                // Usa a direção atual
            }
            
            let checkX = currentPosition.x;
            let checkY = currentPosition.y;

            // 0: Right (+x), 1: Down (+y), 2: Left (-x), 3: Up (-y)
            switch (dir) {
                case 0: checkX++; break; 
                case 1: checkY++; break; 
                case 2: checkX--; break; 
                case 3: checkY--; break; 
            }

            // Verifica limites e paredes
            if (checkX < 0 || checkX >= MAZE_SIZE || checkY < 0 || checkY >= MAZE_SIZE) {
                return false; 
            }
            
            return MAZE[checkY][checkX] !== 0; 
        };
        
        // --- LÓGICA DE DESENHO (Canvas) ---

        /**
         * Desenha o Robô Zoy estilizado no canvas.
         */
        function drawZoyRobot(x, y, tileSize, direction) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const robotSize = tileSize * 0.7;
            const bodySize = robotSize * 0.7;
            const headRadius = robotSize * 0.25;

            ctx.save();
            ctx.translate(centerX, centerY);
            // Rotaciona: 0=Right (0 rad), 1=Down (PI/2), 2=Left (PI), 3=Up (3PI/2)
            ctx.rotate(direction * Math.PI / 2); 

            // 1. Corpo (Zoy Blue)
            ctx.fillStyle = ROBOT_COLOR;
            ctx.fillRect(-bodySize / 2, -bodySize / 2, bodySize, bodySize);
            
            // 2. Cabeça/Face (Branco) - Deslocada para frente (direção 0)
            const headOffset = bodySize / 2;
            ctx.fillStyle = FACE_COLOR;
            ctx.beginPath();
            ctx.arc(headOffset + headRadius * 0.2, 0, headRadius, 0, Math.PI * 2);
            ctx.fill();

            // 3. Antenas/Indicador de Direção (Zoy Dark)
            ctx.fillStyle = '#0f172a';
            const antennaLength = robotSize * 0.3;
            const antennaWidth = robotSize * 0.08;

            // Antena Superior
            ctx.fillRect(headOffset + headRadius * 0.2, -headRadius - antennaLength, antennaWidth, antennaLength);
            // Antena Inferior
            ctx.fillRect(headOffset + headRadius * 0.2, headRadius, antennaWidth, antennaLength);


            ctx.restore();
        }


        function drawMaze() {
            if (!ctx) return;

            const canvasSize = Math.min(canvas.width, canvas.height);
            // MAZE_SIZE é dinâmico agora (5, 7 ou 8)
            const tileSize = canvasSize / MAZE_SIZE; 
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 1. Desenha as células do labirinto
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const tile = MAZE[y][x];
                    
                    ctx.fillStyle = (tile === 0) ? '#475569' : '#e2e8f0'; // Parede vs Caminho 
                    if (tile === 3) {
                        ctx.fillStyle = '#fcd34d'; // Fim (Objetivo - Amarelo)
                        // Desenha um alvo ou algo para o objetivo
                        ctx.beginPath();
                        ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, tileSize * 0.3, 0, Math.PI * 2);
                        ctx.fillStyle = '#cc8c00';
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 3;
                        ctx.stroke();

                    } else if (tile === 2) {
                        ctx.fillStyle = '#bbf7d0'; // Início (Verde claro)
                    }
                    
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    ctx.strokeStyle = '#94a3b8';
                    ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }

            // 2. Desenha o Robô Zoy (no lugar do Panda)
            drawZoyRobot(currentPosition.x, currentPosition.y, tileSize, currentDirection);
        }

        // --- LÓGICA DE CONTROLE DE CÓDIGO (Interface com Blockly) ---
        
        /** * Gera o código a partir do workspace do Blockly e atualiza o painel de exibição. */
        window.updateCodeDisplay = function() {
            // A variável window.workspaceMaze é definida em zoy_jogos.js
            if (!window.Blockly || !window.workspaceMaze) return;

            const code = window.jsGenerator.workspaceToCode(window.workspaceMaze);
            
            // Envolve o código em uma função JS assíncrona para execução segura
            const finalCode = `(async function() {\n${code}})();`;
            
            const displayElement = document.getElementById('generatedCodeDisplay');
            
            if (displayElement) {
                displayElement.textContent = finalCode;
            }
            // Retorna o código final para uso na execução
            return finalCode;
        };
        
        /** * Inicia a execução do programa Blockly. */
        window.executeProgram = async function() {
            if (window.isRunning) return; // Evita múltiplas execuções
            
            const code = window.updateCodeDisplay(); // Pega o código mais recente
            
            if (!code || code.includes("Nenhum bloco conectado")) {
                window.updateStatus("Conecte os blocos para criar um programa.", 'bg-yellow-200', 'text-yellow-800');
                return;
            }

            // NOVO: MOSTRA O OVERLAY DA JANELA DO CÓDIGO
            const overlay = document.getElementById('codeDisplayOverlay');
            if (overlay) {
                overlay.classList.remove('hidden');
                overlay.style.display = 'flex'; // Torna visível e usa flexbox para centralizar
            }
            
            window.resetGame(); // Reinicia o labirinto antes de começar
            window.isRunning = true;
            window.updateStatus('Executando programa...', 'bg-blue-200', 'text-blue-800');
            
            document.getElementById('btnExecutarPrograma').disabled = true;
            document.getElementById('btnPararPrograma').disabled = false;

            // Execução real do código JS gerado (com as APIs globais)
            try {
                // A função `eval` executa o código JS assíncrono que chama moveForward, turn, etc.
                await eval(code); 
            } catch (e) {
                // Erros esperados que param o loop (colisão, vitória)
                if (e.message !== 'Collision or Game Over' && e.message !== 'Game Over') {
                    window.updateStatus(`ERRO DE EXECUÇÃO: ${e.message}`, 'bg-red-200', 'text-red-900');
                    console.error("Erro na execução do programa Blockly:", e);
                }
            } finally {
                if (window.isRunning) { // Se não foi parado por vitória, colisão ou erro
                    window.updateStatus('Programa Terminado. Reinicie para tentar novamente.', 'bg-gray-200', 'text-gray-700');
                }
                window.isRunning = false;
                document.getElementById('btnExecutarPrograma').disabled = false;
                document.getElementById('btnPararPrograma').disabled = true;
                
                // NOVO: ESCONDE O OVERLAY QUANDO A EXECUÇÃO TERMINA
                if (overlay) {
                    overlay.classList.add('hidden');
                    overlay.style.display = 'none';
                }
            }
        }
        
        /** * Função para parar a execução pelo usuário. */
        window.stopProgram = function() {
            window.isRunning = false; 
            window.updateStatus("Execução interrompida pelo usuário.", 'bg-gray-200', 'text-gray-700');
            document.getElementById('btnExecutarPrograma').disabled = false;
            document.getElementById('btnPararPrograma').disabled = true;

            // NOVO: ESCONDE O OVERLAY QUANDO O USUÁRIO CLICA EM PARAR/FECHAR
            const overlay = document.getElementById('codeDisplayOverlay');
            if (overlay) {
                overlay.classList.add('hidden');
                overlay.style.display = 'none';
            }
        };


        // --- INICIALIZAÇÃO E REDIMENSIONAMENTO ---

        function resizeCanvas() {
            const container = document.getElementById('gameArea');
            if (!container || !canvas) return;
            
            // Garante que o canvas seja quadrado e se ajuste à área
            const size = Math.min(container.clientWidth * 0.9, window.innerHeight * 0.8);
            canvas.width = size;
            canvas.height = size;
            drawMaze();
        }

        function initGameEnvironment() {
            canvas = document.getElementById('gameCanvas');
            
            if (!canvas) {
                 console.error("Canvas não encontrado.");
                 return;
            }
            
            ctx = canvas.getContext('2d');
            // Inicializa a referência global do elemento de status.
            window.statusMessageElement = document.getElementById('statusMessage');
            
            window.addEventListener('resize', resizeCanvas);
            
            // Define a dificuldade inicial (padrão 'easy')
            window.setDifficulty(document.getElementById('difficultySelector').value); 
            resizeCanvas();
        }

        document.addEventListener("DOMContentLoaded", initGameEnvironment);
    </script>
</body>
</html>