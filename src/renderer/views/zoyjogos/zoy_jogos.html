<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zoy Jogos - Labirinto</title>
    <!-- Carregando Tailwind CSS para estética e responsividade -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configuração do Tailwind para usar a fonte Inter e cores personalizadas
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'zoy-blue': '#1e40af',
                        'zoy-dark': '#0f172a',
                        'zoy-light': '#f1f5f9',
                        'panda-color': '#34d399', 
                    }
                }
            }
        }
    </script>
    <!-- Ajustando o caminho do CSS: Sobe 1 nível (views/) e entra em home/ -->
    <!-- Presumindo que o home.css está em uma pasta acima/home/ -->
    <link rel="stylesheet" href="../home/home.css"> 
    <style>
        /* Estilos específicos para a tela de jogos */
        body, html { height: 100%; margin: 0; padding: 0; font-family: 'Inter', sans-serif; background-color: #f0f4f8; }
        
        /* Layout principal: 100% da viewport */
        #mainContainer { display: flex; flex-direction: column; height: 100%; }
        #gameAndBlockly { display: flex; flex-grow: 1; overflow: hidden; }

        /* Área do Jogo */
        #gameArea { 
            flex-basis: 40%; 
            max-width: 40%; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-start; 
            padding: 20px; 
            overflow: auto; 
        }
        
        /* Área do Blockly */
        #blocklyArea { 
            flex-basis: 60%; 
            max-width: 60%; 
            height: 100%;
            border-left: 1px solid #e2e8f0;
        }
        #blocklyGameWorkspace { 
            width: 100%; 
            height: 100%; 
        }

        /* Estilos para a área de status e código (Barra de Controle) */
        #controls { 
            padding: 10px 20px; 
            background-color: #ffffff; 
            border-bottom: 1px solid #e2e8f0; 
            display: flex; 
            align-items: center; 
            gap: 15px; 
        }
        #generatedCodeDisplay { 
            background: #f8fafc; 
            padding: 8px 12px; 
            border: 1px solid #cbd5e1; 
            border-radius: 6px;
            white-space: pre-wrap; 
            word-break: break-word; 
            max-height: 80px; 
            overflow-y: auto; 
            flex-grow: 1; 
            font-size: 0.8rem;
            color: #475569;
            min-width: 250px; 
        }

        /* Estilos do Labirinto (Canvas) */
        #gameCanvas {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            background-color: #fff;
            margin-top: 10px;
        }

        /* Responsividade para telas menores */
        @media (max-width: 1024px) {
            #gameAndBlockly {
                flex-direction: column; 
            }
            #gameArea, #blocklyArea {
                flex-basis: 100%;
                max-width: 100%;
                height: 50vh; 
            }
            #blocklyArea {
                border-left: none;
                border-top: 1px solid #e2e8f0;
            }
        }
    </style>
</head>
<body>
    <div id="mainContainer">
        
        <!-- BARRA DE CONTROLE E CÓDIGO -->
        <div id="controls">
            <!-- NOVO BOTÃO DE VOLTAR -->
            <button 
                class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" 
                id="btnVoltar" 
                onclick="window.electronAPI.goBack()">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-left-short inline-block mr-1" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M12 8a.5.5 0 0 1-.5.5H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H11.5a.5.5 0 0 1 .5.5z"/>
                </svg>
                Voltar para Robótica
            </button>
            
            <button 
                class="bg-zoy-blue hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" 
                id="btnExecutarPrograma" 
                onclick="window.executeProgram()">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill inline-block mr-1" viewBox="0 0 16 16">
                    <path d="m11.596 8.697-5.594 3.996c-.57.408-1.396-.039-1.396-.717V4.118c0-.678.825-1.125 1.396-.717l5.594 3.996a.9.9 0 0 1 0 1.314z"/>
                </svg>
                Executar Programa
            </button>
            <button 
                class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" 
                id="btnPararPrograma" 
                onclick="window.stopProgram()" 
                disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-stop-fill inline-block mr-1" viewBox="0 0 16 16">
                    <path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/>
                </svg>
                Parar
            </button>
            
            <!-- Exibição do Status -->
            <div id="statusMessage" class="px-3 py-1 rounded-lg text-sm bg-gray-100 text-gray-700 font-medium transition duration-150 ease-in-out">
                Pronto para começar.
            </div>

            <!-- Exibição do Código Gerado (Debugging/Referência) -->
            <pre id="generatedCodeDisplay">Nenhum bloco conectado</pre>
        </div>

        <!-- ÁREA DO JOGO E DO BLOCKLY -->
        <div id="gameAndBlockly">
            <!-- Área do Jogo/Labirinto -->
            <div id="gameArea">
                <h3 class="text-xl font-bold mb-4 text-zoy-dark">Labirinto do Panda</h3>
                <canvas id="gameCanvas" width="500" height="500"></canvas>
                <button 
                    class="mt-4 bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" 
                    onclick="window.resetGame()">
                    Reiniciar Labirinto
                </button>
            </div>

            <!-- Área do Blockly -->
            <div id="blocklyArea">
                <div id="blocklyGameWorkspace"></div>
            </div>
        </div>
    </div>

    <!-- TOOLBOX: Deve ter este ID para ser referenciado no JS -->
    <xml id="toolboxMaze" style="display: none">
        <category name="Movimento" colour="#CC6666">
            <block type="maze_moveForward"></block>
            <block type="maze_turn"></block>
        </category>
        <category name="Controle" colour="#5CB85C">
            <block type="controls_repeat_simple"></block>
            <block type="controls_if_path"></block>
        </category>
    </xml>

    <!-- CRUCIAL: Carrega o script de lógica do Blockly e do jogo -->
    <script src="zoy_jogos.js"></script>

    <script>
        // Variáveis Globais de Estado do Jogo
        let canvas, ctx;
        window.isRunning = false; // Flag para controlar a execução (usada por zoy_jogos.js)
        
        // Configurações do Labirinto (5x5)
        // 0=Parede, 1=Caminho, 2=Início (Panda), 3=Fim (Comida)
        const MAZE_SIZE = 5;
        const MAZE = [
            [2, 1, 0, 1, 0], 
            [0, 1, 1, 1, 0],
            [0, 0, 0, 1, 1],
            [1, 1, 1, 0, 1],
            [0, 0, 1, 3, 1]  
        ];

        let currentPosition = { x: 0, y: 0 }; 
        let currentDirection = 0; // 0: Right, 1: Down, 2: Left, 3: Up

        // Referência global para o elemento de status
        window.statusMessageElement = null; 

        // --- FUNÇÕES AUXILIARES DE ESTADO (AGORA GLOBAIS) ---

        /** * Função global para atualizar o status. Usada por zoy_jogos.js. 
         * Acessa window.statusMessageElement para garantir o escopo correto.
         */
        window.updateStatus = function(message, bgClass = 'bg-gray-100', textClass = 'text-gray-700') {
            // Verifica se o elemento de status foi inicializado 
            if (!window.statusMessageElement) {
                console.error("ERRO DE DOM: Elemento statusMessage não encontrado.");
                return;
            }
            window.statusMessageElement.className = `px-3 py-1 rounded-lg text-sm font-medium ${bgClass} ${textClass}`;
            window.statusMessageElement.textContent = message;
        }

        /** Função de atraso (usada pelo código Blockly gerado) */
        window.delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        /** Reinicia o estado do jogo para a posição inicial. */
        window.resetGame = function() { 
            window.isRunning = false;
            // Encontra a posição inicial (tile 2)
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    if (MAZE[y][x] === 2) {
                        currentPosition = { x, y };
                        currentDirection = 0; // Direção inicial: Direita
                        break;
                    }
                }
            }
            window.updateStatus('Labirinto Reiniciado. Pronto para programar!');
            drawMaze();
        }

        // --- FUNÇÕES DE INTERAÇÃO DO JOGO (Chamadas pelo código Blockly gerado) ---
        
        /** Move o Panda uma casa para frente. */
        window.moveForward = async function() {
            if (!window.isRunning) return false;
            
            // Adiciona um atraso para a animação
            await window.delay(300); 

            let newX = currentPosition.x;
            let newY = currentPosition.y;

            // 0: Right (+x), 1: Down (+y), 2: Left (-x), 3: Up (-y)
            switch (currentDirection) {
                case 0: newX++; break;
                case 1: newY++; break;
                case 2: newX--; break;
                case 3: newY--; break;
            }

            // 1. Verifica limites
            if (newX < 0 || newX >= MAZE_SIZE || newY < 0 || newY >= MAZE_SIZE) {
                window.updateStatus('Colisão com a borda do mapa!', 'bg-red-200', 'text-red-900');
                window.isRunning = false;
                throw new Error('Collision or Game Over');
            }

            const nextTile = MAZE[newY][newX];

            // 2. Verifica parede
            if (nextTile === 0) {
                window.updateStatus('Colisão com uma parede!', 'bg-red-200', 'text-red-900');
                window.isRunning = false;
                throw new Error('Collision or Game Over');
            }
            
            // 3. Move o Panda
            currentPosition = { x: newX, y: newY };
            drawMaze();

            // 4. Verifica vitória (tile 3)
            if (nextTile === 3) {
                window.updateStatus('Parabéns! O Panda encontrou a Comida!', 'bg-green-200', 'text-green-800');
                window.isRunning = false;
                throw new Error('Game Over'); 
            }

            return true;
        };

        /** Vira o Panda. */
        window.turn = async function(direction) {
            if (!window.isRunning) return false;
            
            // Adiciona um atraso para a animação
            await window.delay(300);

            if (direction === 'LEFT') {
                currentDirection = (currentDirection + 3) % 4; 
            } else { // 'RIGHT'
                currentDirection = (currentDirection + 1) % 4; 
            }
            drawMaze();
            return true;
        };

        /** Verifica se há caminho livre na direção especificada. */
        window.isPath = function(checkDirection) {
            let dir = currentDirection;
            
            if (checkDirection === 'LEFT') {
                dir = (currentDirection + 3) % 4;
            } else if (checkDirection === 'RIGHT') {
                dir = (currentDirection + 1) % 4;
            }
            
            let checkX = currentPosition.x;
            let checkY = currentPosition.y;

            switch (dir) {
                case 0: checkX++; break; // Right
                case 1: checkY++; break; // Down
                case 2: checkX--; break; // Left
                case 3: checkY--; break; // Up
            }

            // Verifica limites e paredes
            if (checkX < 0 || checkX >= MAZE_SIZE || checkY < 0 || checkY >= MAZE_SIZE) {
                return false; 
            }
            
            return MAZE[checkY][checkX] !== 0; 
        };
        
        // --- LÓGICA DE DESENHO (Canvas) ---

        function drawMaze() {
            if (!ctx) return;

            const canvasSize = Math.min(canvas.width, canvas.height);
            const tileSize = canvasSize / MAZE_SIZE;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 1. Desenha as células do labirinto
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const tile = MAZE[y][x];
                    
                    ctx.fillStyle = (tile === 0) ? '#475569' : '#e2e8f0'; // Parede vs Caminho 
                    if (tile === 3) {
                        ctx.fillStyle = '#fcd34d'; // Fim (Comida - Amarelo)
                    } else if (tile === 2) {
                        ctx.fillStyle = '#bbf7d0'; // Início (Verde claro)
                    }
                    
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    ctx.strokeStyle = '#94a3b8';
                    ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }

            // 2. Desenha o Panda
            ctx.fillStyle = '#34d399'; 
            ctx.beginPath();
            
            const pandaX = currentPosition.x * tileSize + tileSize / 2;
            const pandaY = currentPosition.y * tileSize + tileSize / 2;
            const pandaRadius = tileSize * 0.4;
            
            ctx.arc(pandaX, pandaY, pandaRadius, 0, Math.PI * 2);
            ctx.fill();

            // 3. Desenha a direção do Panda (indicador)
            ctx.fillStyle = '#1e40af';
            ctx.save();
            ctx.translate(pandaX, pandaY);
            // Rotaciona: 0=Right (0 rad), 1=Down (PI/2), 2=Left (PI), 3=Up (3PI/2)
            ctx.rotate(currentDirection * Math.PI / 2); 
            
            ctx.beginPath();
            ctx.moveTo(pandaRadius * 0.8, 0);
            ctx.lineTo(-pandaRadius * 0.4, -pandaRadius * 0.4);
            ctx.lineTo(-pandaRadius * 0.4, pandaRadius * 0.4);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // --- LÓGICA DE CONTROLE DE CÓDIGO (Interface com Blockly) ---
        
        /** * Gera o código a partir do workspace do Blockly e atualiza o painel de exibição.
         * Esta função é chamada pelo listener do workspace (em zoy_jogos.js).
         */
        window.updateCodeDisplay = function() {
            // A variável window.workspaceMaze é definida em zoy_jogos.js
            if (!window.Blockly || !window.workspaceMaze) return;

            // Gera o código em JavaScript (usando o Python Generator para simular a execução)
            const code = Blockly.Python.workspaceToCode(window.workspaceMaze);
            
            // Envolve o código em uma função JS assíncrona para execução segura
            const finalCode = `(async function() {\n${code}})();`;
            
            const displayElement = document.getElementById('generatedCodeDisplay');
            
            if (displayElement) {
                displayElement.textContent = finalCode;
            }
            // Retorna o código final para uso na execução
            return finalCode;
        };

        // --- INICIALIZAÇÃO E REDIMENSIONAMENTO ---

        function resizeCanvas() {
            const container = document.getElementById('gameArea');
            if (!container || !canvas) return;
            
            const size = Math.min(container.clientWidth * 0.9, window.innerHeight * 0.8);
            canvas.width = size;
            canvas.height = size;
            drawMaze();
        }

        function initGameEnvironment() {
            canvas = document.getElementById('gameCanvas');
            
            if (!canvas) {
                 console.error("Canvas não encontrado.");
                 return;
            }
            
            ctx = canvas.getContext('2d');
            // Inicializa a referência global do elemento de status.
            window.statusMessageElement = document.getElementById('statusMessage');
            
            window.addEventListener('resize', resizeCanvas);
            
            window.resetGame(); 
            resizeCanvas();
        }

        document.addEventListener("DOMContentLoaded", initGameEnvironment);
    </script>
</body>
</html>
